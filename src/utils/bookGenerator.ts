import jsPDF from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle } from 'docx';
import { saveAs } from 'file-saver';
import { BookProject } from '../types';

export async function generatePDF(project: BookProject): Promise<void> {
  const pdf = new jsPDF();
  let yPosition = 20;
  
  // Title page
  pdf.setFontSize(24);
  pdf.text('Generated by Author AI', 20, yPosition);
  yPosition += 20;
  
  pdf.setFontSize(16);
  pdf.text(`Book Type: ${project.idea.type}`, 20, yPosition);
  yPosition += 10;
  pdf.text(`Language: ${project.idea.language}`, 20, yPosition);
  yPosition += 20;
  
  pdf.setFontSize(14);
  const ideaLines = pdf.splitTextToSize(`Idea: ${project.idea.idea}`, 170);
  pdf.text(ideaLines, 20, yPosition);
  yPosition += ideaLines.length * 7 + 20;

  // Chapters
  project.outlines.forEach((chapter, index) => {
    if (yPosition > 250) {
      pdf.addPage();
      yPosition = 20;
    }
    
    pdf.setFontSize(18);
    pdf.text(chapter.title, 20, yPosition);
    yPosition += 15;
    
    if (chapter.content) {
      pdf.setFontSize(12);
      const contentLines = pdf.splitTextToSize(chapter.content, 170);
      
      contentLines.forEach((line: string) => {
        if (yPosition > 280) {
          pdf.addPage();
          yPosition = 20;
        }
        pdf.text(line, 20, yPosition);
        yPosition += 7;
      });
    }
    
    yPosition += 15;
  });

  pdf.save(`${project.idea.idea.substring(0, 30)}_book.pdf`);
}

export async function generateWord(project: BookProject): Promise<void> {
  try {
    // Create document sections
    const sections = [];
    
    // Title page
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: "Generated by Author AI", bold: true, size: 32 })],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      })
    );
    
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: project.idea.idea, bold: true, size: 24 })],
        alignment: AlignmentType.CENTER,
        spacing: { after: 300 },
      })
    );
    
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: `Type: ${project.idea.type} | Language: ${project.idea.language}`, size: 16 })],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      })
    );
    
    // Table of Contents
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: "Table of Contents", bold: true, size: 20 })],
        spacing: { before: 400, after: 200 },
      })
    );
    
    project.outlines.forEach((chapter, index) => {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: `${index + 1}. ${chapter.title}` })],
          spacing: { after: 100 },
        })
      );
    });
    
    // Chapters
    project.outlines.forEach((chapter) => {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: chapter.title, bold: true, size: 18 })],
          spacing: { before: 400, after: 200 },
        })
      );
      
      if (chapter.content) {
        const paragraphs = chapter.content.split('\n').filter(p => p.trim());
        paragraphs.forEach((paragraph) => {
          sections.push(
            new Paragraph({
              children: [new TextRun({ text: paragraph.trim() })],
              spacing: { after: 200 },
            })
          );
        });
      }
    });

    const doc = new Document({
      sections: [
        {
          children: sections,
        },
      ],
    });

    const blob = await Packer.toBlob(doc);
    
    const cleanTitle = project.idea.idea.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').substring(0, 30);
    
    saveAs(blob, `${cleanTitle || 'Book'}_AuthorAI.docx`);
  } catch (error) {
    console.error('Error generating Word document:', error);
    throw new Error(`Failed to generate Word document: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function exportToPdf(chapters: { title: string; content: string }[], projectTitle: string): Promise<void> {
  const pdf = new jsPDF();
  let yPosition = 20;

  // Title page
  pdf.setFontSize(24);
  pdf.text(projectTitle, 20, yPosition);
  yPosition += 20;

  pdf.setFontSize(12);
  pdf.text('Generated by Author AI - Director Mode', 20, yPosition);
  yPosition += 20;

  // Chapters
  chapters.forEach((chapter) => {
    if (yPosition > 250) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(18);
    pdf.text(chapter.title, 20, yPosition);
    yPosition += 15;

    if (chapter.content) {
      // Strip HTML tags from content
      const plainText = chapter.content.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ');

      pdf.setFontSize(12);
      const contentLines = pdf.splitTextToSize(plainText, 170);

      contentLines.forEach((line: string) => {
        if (yPosition > 280) {
          pdf.addPage();
          yPosition = 20;
        }
        pdf.text(line, 20, yPosition);
        yPosition += 7;
      });
    }

    yPosition += 15;
  });

  const cleanTitle = projectTitle.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').substring(0, 30);
  pdf.save(`${cleanTitle || 'Book'}_DirectorMode.pdf`);
}

export async function exportToDocx(chapters: { title: string; content: string }[], projectTitle: string): Promise<void> {
  try {
    const sections = [];

    // Title page
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: projectTitle, bold: true, size: 32 })],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      })
    );

    sections.push(
      new Paragraph({
        children: [new TextRun({ text: "Generated by Author AI - Director Mode", size: 16 })],
        alignment: AlignmentType.CENTER,
        spacing: { after: 600 },
      })
    );

    // Table of Contents
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: "Table of Contents", bold: true, size: 20 })],
        spacing: { before: 400, after: 200 },
      })
    );

    chapters.forEach((chapter, index) => {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: `${index + 1}. ${chapter.title}` })],
          spacing: { after: 100 },
        })
      );
    });

    // Chapters
    chapters.forEach((chapter) => {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: chapter.title, bold: true, size: 18 })],
          spacing: { before: 400, after: 200 },
        })
      );

      if (chapter.content) {
        // Strip HTML tags from content
        const plainText = chapter.content.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ');

        const paragraphs = plainText.split('\n').filter(p => p.trim());
        paragraphs.forEach((paragraph) => {
          sections.push(
            new Paragraph({
              children: [new TextRun({ text: paragraph.trim() })],
              spacing: { after: 200 },
            })
          );
        });
      }
    });

    const doc = new Document({
      sections: [
        {
          children: sections,
        },
      ],
    });

    const blob = await Packer.toBlob(doc);

    const cleanTitle = projectTitle.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').substring(0, 30);

    saveAs(blob, `${cleanTitle || 'Book'}_DirectorMode.docx`);
  } catch (error) {
    console.error('Error generating Word document:', error);
    throw new Error(`Failed to generate Word document: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}